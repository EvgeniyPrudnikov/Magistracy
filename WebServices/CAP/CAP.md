#CAP теорема для сервиса новостей

##Модификация сервиса

Разделим функциональность сервиса на 2 части для пользователя:
  - работа с источниками новостей
  - работа с новостями

Будем реализовывать часть 2 (работа с новостями)

Тогда API для клиента будет состоять из двух запросов:
 - получить коллекцию новостей (```GET /news?start_dt=current_date&end_dt=-2&source_id=```)
 - получить конкретную новость (```GET /news/{news_id}```)
 
Однако появляется дополнительное служебное API внутри самого сервиса.

## AP || CP || AC

###Предметная область

Сервис новостей - аггрегатор новостей из различных предопределенных источников (например TUT.by, Onliner.by, habrahabr.ru и тд). То есть сам сервис умеет собирать новостные статьи, обрабатывать их и предоставлять клиентам. Клиенты, в свою очередь, выбирают источники новостей, из которых они хотят видеть новости, сообщают об этом сервису и он предоставляет обработанные каким-то образом статьи (например сжатие, удаление лишней рекламы и тд). 

Система ориентирована на большое количество чтений со стороны пользователей, и относительно маленькое количество записей (как со стороны пользователей так и со стороны источников новостей), так как записи в систему идут от клиентов (модификация или добовление источников) и при сборе статей на источниках. Первое событиие достаточно редкое, второе происходит с некоторой периодичностью, так как новости на источниках появляются не каждую секунду, а через какое-то разумное время (час день и тд, в зависимости от источника).

Также новостные статьи это не информация первой необходимости, тоесть задержки в получении новостей вполне приемлемы.
Также новости все время добовляются и они уникальны, есть уникальный url и timestamp.

Исходя из этого можно сделать вывод о том, что в данной ситуации можно построить AP систему, которая будет отвечать всем требованиям и ограничения сервиса. То есть при расщеплении системы сервис все равно может писать в любую из нод, а пользователи читать. При воссоединении партиций, так как объекты только добовляются и они уникальны, будет происходить безболезненный merge данных.

Merge данных будет выполняться скриптом, который будет жить на каждой из машин, с некоторой периодичностью, например раз в несколько секунд. 

Для корректного merge необходимо для каждого объекта хранить дополнительные флаги, например id машнины с которой он пришел.

###Архитектура

Общая архитектура может выглядеть так:

![alt tag](https://github.com/EvgeniyPrudnikov/Magistracy/blob/master/WebServices/CAP/src/web.PNG)

Также, так как будет происходить merge данных на между серверами, то можно "разгрузить" каждую машину и собирать с неё новости не из всех источников а сделать несколько уникальных источниов для машиты , а потом, по средствам мержа, распространять это на остальные машины.
Это будет выглядеть так:

![alt tag](https://github.com/EvgeniyPrudnikov/Magistracy/blob/master/WebServices/CAP/src/web2.PNG)

###База данных

Так как добовление новостей в базу явление происходящее реже, чем чтение из базы, то для этой системы подойдет БД, котороя умее быстро отвечать на запросы чтения, например mongoDB или MySQL (при правильной разработке схемы, при денормализованных схемах данных, реляционные базы бостаточно быстры при чтении ( + в комплекте ACID)), также можно рассматривать и другие БД, в принципе для этой системы это не особо важно

###Вопросы

1. Исходя из данной архитетуры, где лучше поселить сервис вместе с балансером или вместе с БД?
2. Как тогда нужно будет запускать сервис (если сервис с балансером, то 1 инстанс вместе с nginx и внутри отправлять запросы на чтение на разные базы и если ссервис с БД то 2 отдельных инстанса и чтобы запросы разруливал nginx) ?

Сервис вместе с балансером:
![alt tag](https://github.com/EvgeniyPrudnikov/Magistracy/blob/master/WebServices/CAP/src/web4.PNG)
Сервис вместе с БД:
![alt tag](https://github.com/EvgeniyPrudnikov/Magistracy/blob/master/WebServices/CAP/src/web3.PNG)


 

